# Countdown Timer – Compose Task

## Автор
4wl2d - Томилов Владислав Игоревич

---

# Моё решение:
---

## Архитектура

Проект следует принципам **Clean Architecture** с разделением на слои:

### Структура проекта

```
app/src/main/java/ind/wldd/sportytimer/
├── domain/                    # Доменный слой (бизнес-логика)
│   ├── model/
│   │   └── TimerState.kt     # Модель состояния таймера
│   └── usecase/
│       └── CountdownUseCase.kt # Use case для обратного отсчета
├── presentation/              # Слой представления
│   ├── model/
│   │   └── TimerUiState.kt   # UI-модель состояния
│   ├── viewmodel/
│   │   └── TimerViewModel.kt # ViewModel для управления состоянием
│   └── ui/
│       └── TimerScreen.kt    # Compose UI компоненты
└── MainActivity.kt            # Точка входа приложения
```

### Архитектурные слои

1. **Domain Layer (Доменный слой)**
   - Содержит бизнес-логику приложения
   - Независим от Android-фреймворков
   - `CountdownUseCase` — инкапсулирует логику обратного отсчета
   - `TimerState` — модель данных домена

2. **Presentation Layer (Слой представления)**
   - Управляет UI и взаимодействием с пользователем
   - `TimerViewModel` — управляет состоянием UI через StateFlow
   - `TimerScreen` — Compose UI компоненты
   - `TimerUiState` — модель состояния для UI

3. **MainActivity**
   - Точка входа приложения
   - Настраивает Compose и тему
   - Использует Edge-to-Edge для современного дизайна

---

## Логика работы приложения

### Основной поток работы

1. **Инициализация**
   - При запуске `MainActivity` создается `TimerViewModel`
   - `TimerViewModel` автоматически запускает таймер в `init` блоке
   - Таймер начинает отсчет с 10 секунд

2. **Обратный отсчет**
   - `CountdownUseCase.execute(10)` создает Flow, который:
     - Эмитит начальное значение (10)
     - Каждую секунду уменьшает значение на 1
     - Эмитит новое значение до достижения 0
   - Используется `delay(1000)`(пробовал с ticker flow api, решил не оверинженерить)

3. **Управление состоянием**
   - `TimerViewModel` подписывается на Flow через `collect`
   - Обновляет `TimerUiState` при каждом новом значении
   - Отслеживает состояние: `isRunning` и `isFinished`

4. **Отображение**
   - `TimerScreen` наблюдает за `uiState` через `collectAsStateWithLifecycle`
   - UI автоматически обновляется при изменении состояния
   - Отображается текущее значение таймера крупным шрифтом

---

## Используемые технологии и библиотеки

### Основные технологии

1. **Jetpack Compose** (`compose-bom: 2026.01.00`)

2. **Kotlin Coroutines** (`kotlinx-coroutines-android: 1.10.2`)

3. **ViewModel** (`lifecycle-viewmodel-compose: 2.10.0`)

4. **Lifecycle Runtime Compose** (`lifecycle-runtime-compose: 2.10.0`)

### Версии и конфигурация

- **Min SDK**: 26 (Android 8.0)
- **Target SDK**: 36
- **Compile SDK**: 36
- **Kotlin**: 2.3.0
- **AGP**: 9.0.0

---

## Что можно было использовать, но не использовал

### 1. WorkManager

**Почему не использовал:**
- Таймер работает только когда приложение активно
- Нет требований к фоновой работе
- Использование корутин в ViewModel достаточно для задачи

**Когда стоило бы использовать:**
- Если нужен таймер, работающий в фоне
- Если требуется уведомление по завершении
- Если нужно продолжать отсчет при закрытии приложения

### 2. Compose Runtime для таймера (LaunchedEffect, DisposableEffect)

**Почему не использовал:**
- Таймер реализован на уровне ViewModel, что обеспечивает лучшую тестируемость
- Логика таймера отделена от UI, что соответствует Clean Architecture
- ViewModel переживает изменения конфигурации, а Compose-эффекты могут перезапускаться
- Использование `LaunchedEffect` в UI-слое смешало бы бизнес-логику с представлением

**Когда стоило бы использовать:**
- Для простых UI-анимаций и локальных эффектов
- Если таймер нужен только для визуального отображения без бизнес-логики
- Для одноразовых операций, привязанных к жизненному циклу composable
- Пример: `LaunchedEffect(Unit) { while (active) { delay(1000); /* обновление */ } }`

### 3. RxJava / ReactiveX

**Почему не использовал:**
- Kotlin Coroutines и Flow — нативная поддержка в Kotlin
- Меньше зависимостей: RxJava требует дополнительной библиотеки
- Более простой синтаксис для данной задачи
- Лучшая интеграция с Compose через `collectAsStateWithLifecycle`
- Меньше кривая обучения для Kotlin-разработчиков

**Когда стоило бы использовать:**
- В проектах, где уже используется RxJava
- При необходимости сложных операторов трансформации (combineLatest, zip и т.д.)
- При работе с legacy-кодом на RxJava
- Если команда уже знакома с ReactiveX

### 4. MVI-фреймворки (FlowMVI, Orbit MVI, MVIKotlin)

**Почему не использовал:**
- Простота задачи не требует сложной архитектуры состояний
- ViewModel + StateFlow достаточно для управления состоянием
- MVI добавляет дополнительный слой абстракции (Intent/Action → State)
- Увеличивает количество кода и сложность для простого таймера

**Когда стоило бы использовать:**
- В сложных приложениях с множеством экранов и состояний
- Когда нужна предсказуемость изменений состояния (unidirectional data flow)
- При работе в команде, где MVI является стандартом
- Если требуется time-travel debugging или логирование всех действий

**Что дал бы MVI:**
- Четкое разделение на Intent (действия) → State (состояние)
- Предсказуемый поток данных: все изменения через один канал
- Легче отслеживать источник изменений состояния
- Пример структуры: `TimerIntent.Start → TimerState.Running → TimerIntent.Tick → TimerState.Updated`

**Почему текущий подход достаточен:**
- StateFlow уже обеспечивает реактивное обновление UI
- ViewModel инкапсулирует логику изменения состояния
- Меньше boilerplate-кода
- Проще понять и поддерживать для простых случаев